# v0.3.3 Ray Marching Opacity Consistency

**Type:** Bug Fix (Breaking Visual Change)
**Status:** Design Complete
**Target Version:** v0.3.3

## Problem Statement

The current ray marching implementation has a critical bug where rendering quality presets produce visually inconsistent results. When using different step sizes across quality presets (preview: 0.05, fast: 0.02, balanced: 0.01, high_quality: 0.005, ultra: 0.001), the same transfer function produces drastically different opacity:

- **High quality presets** (smaller step sizes) take more samples per unit length
- Each sample contributes opacity from the transfer function
- Result: More samples = more opacity accumulation = darker, more opaque appearance
- **This violates physical correctness** - the same volume with the same transfer function should look the same regardless of sampling resolution

### Root Cause

The shader applies transfer function alpha directly without correcting for step size (lines 110-111 in `volume.frag.glsl`):

```glsl
accumulated_color += (1.0 - accumulated_alpha) * sample_color;
accumulated_alpha += (1.0 - accumulated_alpha) * sample_color.a;
```

The transfer function defines opacity at some implicit reference step size, but when rendering at different step sizes, the opacity must be scaled to maintain physical consistency.

### Impact

- Users cannot reliably switch between quality presets
- Transfer functions designed for one preset look wrong at others
- Scientific visualization results are not reproducible
- Violates Beer-Lambert law for light absorption
- Pre-1.0 bug that must be fixed before API stabilization

## Solution: Opacity Correction

### Physical Basis

Implement opacity correction based on Beer-Lambert law, which describes how light is absorbed through a medium:

```
I = I₀ * exp(-τ * d)
```

Where τ (tau) is the extinction coefficient and d is the distance traveled.

### Correction Formula

```glsl
alpha_step_size_corrected = 1.0 - exp(-alpha_tf * step_size / reference_step_size)
```

Where:
- `alpha_tf`: Raw alpha from transfer function (0.0 to 1.0)
- `step_size`: Current rendering step size (from RenderConfig)
- `reference_step_size`: The step size the transfer function was designed for (new parameter)
- `alpha_step_size_corrected`: The physically correct alpha to use for accumulation

### Why Exponential Correction?

- Physically accurate (Beer-Lambert law)
- Industry standard (VTK, ParaView, OSPRay)
- Works correctly across wide range of step sizes
- Maintains consistency: rendering at any quality preset produces the same appearance

### Result

After correction, all quality presets (preview through ultra) will produce visually identical results, differing only in smoothness/sampling quality, not overall opacity/brightness.

## API Changes

### RenderConfig

Add new parameter `reference_step_size` to `RenderConfig`:

```python
@dataclass
class RenderConfig:
    step_size: float
    max_steps: int
    early_ray_termination: bool = True
    opacity_threshold: float = 0.95
    reference_step_size: float = 0.01  # NEW
```

**Default Value**: 0.01 (matches the "balanced" preset step size)

**Usage Guidelines**:
- Transfer functions are typically designed/tested at balanced quality
- Provides sensible default for most use cases
- Users can override based on their dataset characteristics

**When to Adjust**:
- **Feature-dense volumes** (medical scans, turbulence): Use smaller reference (0.005-0.008)
- **Simple volumes** (synthetic datasets, smooth fields): Use larger reference (0.015-0.02)
- **Guideline**: Set reference_step_size to match the step size you use when designing transfer functions

**Preset Behavior**: All quality presets keep their existing step_size values unchanged. The reference_step_size is independent and applies across all presets.

### Example Usage

```python
# Basic usage - default reference works for most cases
config = RenderConfig.high_quality()
renderer = VolumeRenderer(config=config)

# For feature-dense medical data
config = RenderConfig.balanced()
config.reference_step_size = 0.005

# For simple synthetic volumes
config = RenderConfig.fast()
config.reference_step_size = 0.015
```

## Implementation Details

### Shader Changes

**File**: `pyvr/shaders/volume.frag.glsl`

**New Uniform** (add after line 10):
```glsl
uniform float reference_step_size;
```

**Correction Application** (modify lines 95-108):
```glsl
// Single RGBA texture lookup for transfer function
vec4 rgba = texture(transfer_function_lut, vec2(density, 0.5));
vec3 rgb = rgba.rgb;
float alpha_tf = rgba.a;

// Apply step-size correction (Beer-Lambert law)
float alpha_step_size_corrected = 1.0 - exp(-alpha_tf * step_size / reference_step_size);

// Use corrected alpha for lighting and accumulation
vec3 normal = texture(normal_volume, tex_coord).rgb;
normal = normalize(normal);

vec3 light_dir = normalize(light_target - light_position);
float diffuse_intensity = max(dot(normal, light_dir), 0.0);
float light = ambient_light + diffuse_light * diffuse_intensity;

vec4 sample_color = vec4(rgb * light, alpha_step_size_corrected);
```

**Key Points**:
- Correction happens immediately after transfer function lookup
- Corrected alpha (`alpha_step_size_corrected`) replaces raw alpha everywhere after
- Early ray termination threshold (0.99) remains unchanged at line 86
- No conditional logic - correction is always applied (always-on, not toggleable)

### Renderer Changes

**File**: `pyvr/moderngl_renderer/renderer.py`

**Update `set_config()` method**:
```python
def set_config(self, config: RenderConfig) -> None:
    """Update render configuration."""
    self._config = config
    if self.program is not None:
        self.program['step_size'].value = config.step_size
        self.program['max_steps'].value = config.max_steps
        self.program['reference_step_size'].value = config.reference_step_size  # NEW
```

**Update constructor** (wherever shader uniforms are initialized):
```python
# Set rendering parameters
self.program['step_size'].value = self._config.step_size
self.program['max_steps'].value = self._config.max_steps
self.program['reference_step_size'].value = self._config.reference_step_size  # NEW
```

**No changes to**:
- `ModernGLManager`: Shader compilation handles new uniform automatically
- Getters: `reference_step_size` accessible via `renderer.get_config().reference_step_size`

## Testing Strategy

### Unit Tests

**New file**: `tests/test_config_opacity_correction.py`

```python
import pytest
import numpy as np
from pyvr.config import RenderConfig

def test_reference_step_size_default():
    """Test that reference_step_size defaults to 0.01."""
    config = RenderConfig.balanced()
    assert config.reference_step_size == 0.01

def test_opacity_correction_formula():
    """Test the opacity correction math matches Beer-Lambert law."""
    # When step_size == reference_step_size, correction should be minimal
    alpha_tf = 0.5
    step_size = 0.01
    reference = 0.01

    # Formula: 1.0 - exp(-alpha_tf * step_size / reference)
    corrected = 1.0 - np.exp(-alpha_tf * step_size / reference)
    assert np.isclose(corrected, alpha_tf, rtol=0.1)  # Should be close to original

def test_opacity_correction_smaller_step():
    """Test that smaller step size produces smaller corrected alpha."""
    alpha_tf = 0.5
    reference = 0.01

    corrected_small = 1.0 - np.exp(-alpha_tf * 0.005 / reference)
    corrected_large = 1.0 - np.exp(-alpha_tf * 0.02 / reference)

    assert corrected_small < corrected_large

def test_opacity_correction_edge_cases():
    """Test edge cases: alpha=0, alpha=1."""
    reference = 0.01
    step = 0.005

    # alpha=0 should stay 0
    assert 1.0 - np.exp(-0.0 * step / reference) == 0.0

    # alpha=1 should be high but not exceed 1
    corrected = 1.0 - np.exp(-1.0 * step / reference)
    assert 0.0 < corrected < 1.0
```

### Visual Comparison Test

Documented in version notes:

1. Render test volume (sphere or double_sphere) at all 5 presets
2. Visual inspection: all should have similar overall opacity/brightness
3. Differences should only be in smoothness/sampling artifacts
4. Document with before/after screenshots in version notes

## Breaking Changes

### What Changes

- **High quality presets** (high_quality, ultra_quality) will render **lighter/less opaque** than before
- **Low quality presets** (preview, fast) will render **darker/more opaque** than before
- **Balanced preset** will look similar (reference_step_size = 0.01 matches balanced step_size)

### Why This Happens

- **Before**: High quality took more samples → accumulated more opacity (bug)
- **After**: All presets accumulate opacity correctly → consistent appearance

### Migration Path for Users

**Option 1: Adjust transfer function opacity**:
```python
# If your renders look too light after upgrade, increase opacity
otf = OpacityTransferFunction(control_points=[
    (0.0, 0.0),
    (0.5, 0.6),  # Was 0.4, increased to compensate
    (1.0, 1.0)
])
```

**Option 2: Adjust reference_step_size**:
```python
# Make reference smaller → renders appear more opaque
config = RenderConfig.balanced()
config.reference_step_size = 0.005
```

**Recommended**: Re-design transfer functions at balanced quality. They will now work correctly at all presets.

### Version Notes

Version notes (`version_notes/v0.3.3_ray_marching_consistency.md`) will include:
- Problem statement with before/after screenshots
- Technical explanation of Beer-Lambert correction
- Breaking changes section with migration guide
- Visual comparison across all presets showing consistency

## Documentation Updates

### RenderConfig Docstring

```python
reference_step_size: float = 0.01
    """Reference step size for opacity correction.

    Transfer functions define opacity at this reference step size.
    When rendering at different step sizes, opacity is corrected
    using Beer-Lambert law to maintain physical consistency.

    Guidelines:
    - Feature-dense volumes (medical, turbulence): 0.005-0.008
    - Simple volumes (synthetic, smooth fields): 0.015-0.02
    - Default (0.01): Matches balanced preset, good for most cases

    The same transfer function will produce identical appearance
    across all quality presets when reference_step_size is set correctly.
    """
```

### Files to Update

- `README.md`: Add note about opacity correction in RenderConfig section
- `CLAUDE.md`: Update v0.3.3 version history entry
- `pyvr/config.py`: Add docstring for reference_step_size parameter
- `version_notes/v0.3.3_ray_marching_consistency.md`: Complete release notes

## Implementation Phases

**Phase 1: Core Implementation**
- Add `reference_step_size` to RenderConfig
- Modify shader to apply opacity correction
- Update renderer to pass uniform to shader

**Phase 2: Testing**
- Add unit tests for correction formula
- Visual comparison test across all presets
- Verify consistency with test volumes

**Phase 3: Documentation**
- Write version notes with before/after screenshots
- Update README and CLAUDE.md
- Add migration guide for users

## Success Criteria

- [ ] All quality presets produce visually consistent results (same opacity, different smoothness)
- [ ] Unit tests pass for correction formula edge cases
- [ ] Visual comparison confirms consistency across presets
- [ ] Documentation clearly explains breaking change and migration
- [ ] No regression in existing functionality

## Benefits

1. **Physical Correctness**: Implements Beer-Lambert law for opacity
2. **Preset Consistency**: All quality presets produce same appearance
3. **Scientific Validity**: Results are reproducible and physically meaningful
4. **Industry Standard**: Matches behavior of VTK, ParaView, OSPRay
5. **User Flexibility**: reference_step_size allows tuning per dataset
6. **Pre-1.0 Fix**: Critical bug fixed before API stabilization

## Risks and Mitigations

**Risk**: Breaking visual change frustrates existing users
**Mitigation**: Clear documentation, migration guide, pre-1.0 acceptable breaking changes

**Risk**: Users don't understand reference_step_size
**Mitigation**: Good default (0.01), clear docstrings, usage examples

**Risk**: Formula has edge cases or numerical issues
**Mitigation**: Comprehensive unit tests, visual validation

## References

- Beer-Lambert Law: https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law
- VTK Volume Rendering: https://vtk.org/doc/nightly/html/classvtkVolumeProperty.html
- OSPRay Transfer Functions: https://www.ospray.org/documentation.html
