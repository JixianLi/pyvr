# Phase 04: Fix Auto-Quality Threading Bug

**Feature:** v0.3.3 Ray Marching Opacity Consistency
**Phase:** 04 of 04
**Focus:** Fix thread-safety violation in auto-quality restoration causing silent crash

## Scope

Fix critical bug in interactive interface where changing quality presets and then zooming causes silent crash. The bug is caused by using `threading.Timer` which executes callbacks in a background thread, but matplotlib GUI operations must occur on the main thread.

This phase implements Option 1 from bug analysis: Replace `threading.Timer` with matplotlib's native `fig.canvas.new_timer()` to ensure all GUI operations execute on the main thread.

## Problem Summary

### Bug Reproduction
1. Launch `InteractiveVolumeRenderer`
2. Select different quality preset (e.g., "High Quality")
3. Scroll mouse wheel to zoom
4. **Program crashes silently ~0.5 seconds later**

### Root Cause

**Location**: `pyvr/interface/matplotlib_interface.py:502`

```python
# WRONG: Creates timer that fires in background thread
self._scroll_restore_timer = threading.Timer(0.5, self._restore_quality_after_interaction)
self._scroll_restore_timer.start()
```

**Problem**: When timer fires after 0.5s:
1. Callback executes in background thread (Thread-1, not MainThread)
2. Calls `preset_selector.set_preset()` from background thread
3. This modifies matplotlib RadioButtons widget from non-main thread
4. Matplotlib is NOT thread-safe ‚Üí CRASH

**Thread Flow**:
```
MainThread: _on_scroll() ‚Üí threading.Timer.start()
            ‚Üì (0.5s delay)
Thread-1:   _restore_quality_after_interaction() ‚ùå
            ‚Üí preset_selector.set_preset() ‚ùå GUI from wrong thread
            ‚Üí radio.set_active() ‚ùå Native GUI toolkit crash
```

### Impact
- **Severity**: HIGH - causes data loss and user frustration
- **Frequency**: Common workflow (change preset + zoom)
- **Symptoms**: Silent crash, window closes unexpectedly
- **Affected**: All users with `auto_quality_enabled=True` (default)

## Solution: Use Matplotlib's Native Timer

Replace `threading.Timer` with `fig.canvas.new_timer()` which executes callbacks on the main thread.

### Why This Works

**Matplotlib Timer Benefits**:
- Callbacks execute on main/GUI thread (thread-safe)
- Native integration with matplotlib event loop
- Works across all backends (TkAgg, Qt5Agg, etc.)
- Same functionality (single-shot, cancellable)

**Thread-Safe Flow**:
```
MainThread: _on_scroll() ‚Üí fig.canvas.new_timer()
            ‚Üì (0.5s delay, stays on MainThread)
MainThread: _restore_quality_after_interaction() ‚úì
            ‚Üí preset_selector.set_preset() ‚úì GUI on correct thread
            ‚Üí radio.set_active() ‚úì Safe
```

## Implementation

### Task 1: Replace threading.Timer in _on_scroll

**File**: `pyvr/interface/matplotlib_interface.py`

**Changes**:

1. Remove threading import from `_on_scroll` method (line 497)
2. Replace timer creation (lines 498-503)

**Before** (lines 496-503):
```python
# Restore quality after short delay
if self.state.auto_quality_enabled:
    import threading
    # Cancel any existing timer
    if hasattr(self, '_scroll_restore_timer') and self._scroll_restore_timer is not None:
        self._scroll_restore_timer.cancel()
    # Start new timer
    self._scroll_restore_timer = threading.Timer(0.5, self._restore_quality_after_interaction)
    self._scroll_restore_timer.start()
```

**After**:
```python
# Restore quality after short delay
if self.state.auto_quality_enabled:
    # Cancel any existing timer
    if hasattr(self, '_scroll_restore_timer') and self._scroll_restore_timer is not None:
        self._scroll_restore_timer.stop()

    # Create matplotlib timer (executes on main thread, not background thread)
    self._scroll_restore_timer = self.fig.canvas.new_timer(interval=500)  # 500ms
    self._scroll_restore_timer.add_callback(self._restore_quality_after_interaction)
    self._scroll_restore_timer.single_shot = True
    self._scroll_restore_timer.start()
```

**Key Changes**:
- `threading.Timer` ‚Üí `self.fig.canvas.new_timer()`
- `interval=500` (milliseconds, not 0.5 seconds)
- `add_callback()` instead of passing function to constructor
- `single_shot = True` (fires once then stops)
- `.cancel()` ‚Üí `.stop()` (matplotlib timer API)

**Notes**:
- `self.fig` is available because `_on_scroll` only called after `show()` creates figure
- No need for `import threading`
- Timer automatically cleaned up when figure closes

### Task 2: Verify No Other Threading.Timer Usage

**File**: `pyvr/interface/matplotlib_interface.py`

**Action**: Search entire file for other uses of `threading.Timer`

**Expected**: Only one usage (in `_on_scroll` which we're fixing)

**Verification**:
```bash
# Search for threading imports
grep -n "import threading" pyvr/interface/matplotlib_interface.py

# Search for threading.Timer usage
grep -n "threading.Timer" pyvr/interface/matplotlib_interface.py
```

Should find only the one instance we're fixing.

### Task 3: Verify Similar Pattern Not Used Elsewhere

**Action**: Check for similar auto-quality patterns that might have same bug

**Locations to check**:
- `_on_mouse_release()` (lines 380-407): Uses auto-quality but restores immediately (no timer) ‚úì OK
- `_on_mouse_press()` (lines 355-378): Switches to interaction quality but no restoration timer ‚úì OK

**Expected**: No other timer-based quality restoration

### Task 4: Update Comments and Documentation

**File**: `pyvr/interface/matplotlib_interface.py`

**Changes**:

Add explanatory comment above timer creation:

```python
# Restore quality after short delay
if self.state.auto_quality_enabled:
    # Cancel any existing timer
    if hasattr(self, '_scroll_restore_timer') and self._scroll_restore_timer is not None:
        self._scroll_restore_timer.stop()

    # Create matplotlib timer (thread-safe: executes on main thread)
    # Using fig.canvas.new_timer instead of threading.Timer to avoid
    # thread-safety violations when updating matplotlib widgets
    self._scroll_restore_timer = self.fig.canvas.new_timer(interval=500)  # 500ms
    self._scroll_restore_timer.add_callback(self._restore_quality_after_interaction)
    self._scroll_restore_timer.single_shot = True
    self._scroll_restore_timer.start()
```

## Verification Steps

### Step 1: Code Verification

```bash
# Verify no threading.Timer remains
grep -r "threading.Timer" pyvr/interface/

# Should return no matches in matplotlib_interface.py
```

### Step 2: Manual Reproduction Test

**Before Fix**: Bug reproduction
```bash
cd /Users/jixianli/projects/pyvr
python tmp_dev/reproduce_zoom_crash.py
```

Expected: Crash occurs

**After Fix**: Verify bug is fixed
```bash
python tmp_dev/reproduce_zoom_crash.py
```

Expected: No crash, smooth operation

**Test Steps**:
1. Interface loads successfully
2. Click "High Quality" preset
3. Scroll to zoom multiple times
4. Wait 1+ seconds between scrolls
5. No crash, quality restores smoothly
6. Preset selector updates correctly
7. Can continue interacting normally

### Step 3: Instrumented Test

Run instrumented test to verify thread-safety:

```bash
python tmp_dev/trace_threading_bug.py
```

**Expected Console Output** (after fix):
```
[SCROLL] _on_scroll() called
  Thread: MainThread (id=...)
  Main thread: True
  ‚úì _on_scroll() completed successfully

[TIMER] Creating Timer with 500ms delay
  Will call: _restore_quality_after_interaction()
  Created from thread: MainThread
  ‚ö†Ô∏è  Using matplotlib timer (executes on main thread)

(wait 0.5 seconds...)

[RESTORE] _restore_quality_after_interaction() called
  Thread: MainThread (id=...)  ‚Üê MAIN THREAD NOW! ‚úì
  Main thread: True
  ‚úì _restore_quality_after_interaction() completed successfully

[PRESET] PresetSelector.set_preset('high_quality') called
  Thread: MainThread  ‚Üê CORRECT! ‚úì
  Main thread: True
  ‚úì set_preset() completed successfully
```

**Key difference**: All callbacks now execute on MainThread instead of Thread-1

### Step 4: Backend Compatibility Test

Test with different matplotlib backends to ensure timer works correctly:

```python
# Test with TkAgg (default)
import matplotlib
matplotlib.use('TkAgg')
# ... run interface ...

# Test with Qt5Agg (if available)
import matplotlib
matplotlib.use('Qt5Agg')
# ... run interface ...
```

Expected: Timer works correctly on all backends

### Step 5: Regression Testing

Verify other interface functionality still works:

**Test Cases**:
1. **Camera drag** (auto-quality should work)
   - Drag to orbit ‚Üí switches to fast
   - Release ‚Üí restores previous quality

2. **Manual preset changes** (should work immediately)
   - Click different presets
   - Changes take effect immediately

3. **Multiple rapid scrolls** (timer cancellation)
   - Scroll multiple times quickly
   - Only final restoration should occur
   - No crashes or errors

4. **Disable auto-quality** (timer should not be created)
   - Press 'q' to disable auto-quality
   - Scroll to zoom
   - No quality switching, no timer created

5. **Interface shutdown** (timer cleanup)
   - Close interface window
   - No errors or hanging threads

## Testing Script

Create comprehensive test to validate fix:

**File**: `tmp_dev/test_threading_fix.py`

```python
#!/usr/bin/env python3
"""
Test script to validate threading bug fix.

Tests:
1. No crash on preset change + zoom
2. Timer executes on main thread
3. Multiple scrolls work correctly
4. Timer cleanup on shutdown
"""

import numpy as np
from pyvr.datasets import create_sample_volume
from pyvr.volume import Volume
from pyvr.interface import InteractiveVolumeRenderer
from pyvr.config import RenderConfig


def test_no_crash():
    """Test that preset change + zoom does not crash."""
    print("Test 1: No crash on preset change + zoom")
    print("-" * 60)

    volume_data = create_sample_volume(128, 'sphere')
    volume = Volume(data=volume_data)

    interface = InteractiveVolumeRenderer(
        volume=volume,
        width=512,
        height=512,
        config=RenderConfig.fast()
    )

    # Simulate preset change
    interface._on_preset_change('high_quality')
    print("‚úì Changed to high_quality preset")

    # Simulate scroll (zoom)
    # We can't easily simulate matplotlib events, but we can call the method
    class FakeEvent:
        def __init__(self):
            self.inaxes = None
            self.step = 1  # scroll up

    # This would normally be called by matplotlib
    # event.inaxes = interface.image_display.ax
    # For testing, we'll just verify the method exists and doesn't crash

    print("‚úì Interface initialized without crash")
    print("‚úì Test passed - would need manual verification for full test")
    print()


def test_timer_type():
    """Verify timer is matplotlib timer, not threading.Timer."""
    print("Test 2: Timer type verification")
    print("-" * 60)

    volume_data = create_sample_volume(64, 'sphere')
    volume = Volume(data=volume_data)

    interface = InteractiveVolumeRenderer(
        volume=volume,
        width=256,
        height=256,
        config=RenderConfig.fast()
    )

    # Create figure (required for timer)
    interface.fig, _ = interface._create_layout()

    # Create timer manually
    timer = interface.fig.canvas.new_timer(interval=500)
    timer.single_shot = True

    # Verify it's not threading.Timer
    import threading
    assert not isinstance(timer, threading.Timer), \
        "Should not be threading.Timer"

    # Verify it has expected methods
    assert hasattr(timer, 'start'), "Should have start method"
    assert hasattr(timer, 'stop'), "Should have stop method"
    assert hasattr(timer, 'add_callback'), "Should have add_callback method"

    print(f"‚úì Timer type: {type(timer)}")
    print("‚úì Timer has correct API")
    print("‚úì Test passed")
    print()


def test_auto_quality_setting():
    """Verify auto-quality can be enabled/disabled."""
    print("Test 3: Auto-quality enable/disable")
    print("-" * 60)

    volume_data = create_sample_volume(64, 'sphere')
    volume = Volume(data=volume_data)

    interface = InteractiveVolumeRenderer(
        volume=volume,
        width=256,
        height=256,
        config=RenderConfig.balanced()
    )

    # Should be enabled by default
    assert interface.state.auto_quality_enabled == True, \
        "Auto-quality should be enabled by default"
    print("‚úì Auto-quality enabled by default")

    # Disable it
    interface.state.auto_quality_enabled = False
    assert interface.state.auto_quality_enabled == False, \
        "Should be able to disable auto-quality"
    print("‚úì Can disable auto-quality")

    # Re-enable it
    interface.state.auto_quality_enabled = True
    assert interface.state.auto_quality_enabled == True, \
        "Should be able to re-enable auto-quality"
    print("‚úì Can re-enable auto-quality")

    print("‚úì Test passed")
    print()


if __name__ == "__main__":
    print("=" * 60)
    print("THREADING BUG FIX VALIDATION TESTS")
    print("=" * 60)
    print()

    try:
        test_no_crash()
        test_timer_type()
        test_auto_quality_setting()

        print("=" * 60)
        print("ALL AUTOMATED TESTS PASSED")
        print("=" * 60)
        print()
        print("Manual testing required:")
        print("1. Run: python tmp_dev/reproduce_zoom_crash.py")
        print("2. Follow instructions to test preset change + zoom")
        print("3. Verify no crash occurs")

    except AssertionError as e:
        print()
        print("=" * 60)
        print("TEST FAILED")
        print("=" * 60)
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        exit(1)
    except Exception as e:
        print()
        print("=" * 60)
        print("UNEXPECTED ERROR")
        print("=" * 60)
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        exit(1)
```

Run test:
```bash
python tmp_dev/test_threading_fix.py
```

## Acceptance Criteria

- [ ] `threading.Timer` removed from `_on_scroll()` method
- [ ] Replaced with `fig.canvas.new_timer()` with 500ms interval
- [ ] Timer set to single_shot mode
- [ ] Timer callback added with `add_callback()`
- [ ] Timer cancellation uses `.stop()` instead of `.cancel()`
- [ ] No other `threading.Timer` usage in interface code
- [ ] Comments added explaining thread-safety rationale
- [ ] Manual test confirms no crash on preset change + zoom
- [ ] Instrumented test shows callbacks execute on MainThread
- [ ] Multiple rapid scrolls work correctly (timer cancellation)
- [ ] Interface shutdown cleans up timer without errors
- [ ] All existing interface functionality still works (regression tests)
- [ ] Code follows existing style and conventions
- [ ] No new dependencies or imports required

## Git Commit

**When all acceptance criteria are met**, commit with:

```bash
git add pyvr/interface/matplotlib_interface.py
git commit -m "$(cat <<'EOF'
fix(interface): Fix thread-safety violation in auto-quality restoration

Replace threading.Timer with matplotlib's native timer to prevent
crash when changing quality presets and zooming.

Bug: When user changed quality preset then scrolled to zoom, the
program would crash silently after ~0.5 seconds. This occurred
because threading.Timer executes callbacks in a background thread,
but matplotlib GUI operations must occur on the main thread.

Fix: Use fig.canvas.new_timer() which executes callbacks on the
main thread, making all GUI operations thread-safe.

Changes:
- Replace threading.Timer with fig.canvas.new_timer(interval=500)
- Use single_shot mode for one-time callback
- Update timer cancellation from .cancel() to .stop()
- Add comments explaining thread-safety requirements

Impact: Critical bug fix - prevents data loss and user frustration
from silent crashes. No API changes, fully backward compatible.

Testing: Manual reproduction test confirms bug is fixed. Instrumented
test verifies all callbacks execute on MainThread.

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

## Notes for Integration

### Related to Phases 01-03

This phase is independent of the opacity correction work in phases 01-03:
- **No dependencies**: Can be implemented in any order
- **No conflicts**: Different files/functionality
- **Same version**: Both ship in v0.3.3

### Bug Analysis Documentation

Bug analysis in `tmp_dev/` provides additional context:
- `BUG_ANALYSIS_zoom_crash.md`: Detailed root cause analysis
- `thread_flow_diagram.txt`: Visual thread flow diagram
- `reproduce_zoom_crash.py`: Reproduction script
- `trace_threading_bug.py`: Instrumented debugging script

These files can be deleted after fix is verified, or kept for reference.

### Alternative Solutions (Not Implemented)

Other approaches considered but rejected:
- **Option 2**: Queue callback for main thread - more complex, backend-specific
- **Option 3**: Disable auto-quality by default - removes useful feature
- **Option 4**: Remove delayed restoration - less responsive UX

Option 1 (matplotlib timer) is the best solution: simple, thread-safe, cross-platform.

## Validation

### Success Indicators

After implementing this phase:

1. **No crashes**: Preset change + zoom workflow works reliably
2. **Thread-safe**: All callbacks execute on MainThread
3. **Same UX**: Auto-quality behavior unchanged from user perspective
4. **Clean code**: No threading imports in interface code
5. **Maintainable**: Clear comments explain thread-safety requirements

### User Experience

Users should notice:
- **Before fix**: Silent crash after preset change + zoom
- **After fix**: Smooth operation, no crashes
- **No other changes**: Auto-quality works exactly the same

The fix is completely transparent - users won't notice anything except the absence of crashes.

## Documentation Updates

### CLAUDE.md

Update v0.3.3 notes to mention bug fix:

```markdown
**v0.3.3** (2025-XX-XX): Ray marching opacity consistency + Interface bug fix
- Fix: Implement Beer-Lambert law for physically correct opacity accumulation
- Fix: Thread-safety violation in auto-quality causing crash on preset change + zoom
...
```

### Version Notes

Add section to `version_notes/v0.3.3_ray_marching_consistency.md`:

```markdown
## Bug Fixes

### Fixed: Thread-Safety Crash in Auto-Quality Restoration

**Issue**: Changing quality preset then zooming would cause silent crash after ~0.5 seconds.

**Cause**: Used `threading.Timer` which executed callback in background thread, but matplotlib
GUI operations must occur on main thread.

**Fix**: Replaced with `fig.canvas.new_timer()` which executes on main thread.

**Impact**: No API changes. Auto-quality feature works the same, just without crashes.
```

## References

- Matplotlib Timer API: https://matplotlib.org/stable/api/backend_bases_api.html#matplotlib.backend_bases.TimerBase
- Matplotlib Thread Safety: https://matplotlib.org/stable/users/explain/performance.html#threading
- Bug Analysis: `tmp_dev/BUG_ANALYSIS_zoom_crash.md`
