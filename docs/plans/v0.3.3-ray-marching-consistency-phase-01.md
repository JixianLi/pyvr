# Phase 01: Core Implementation - Opacity Correction

**Feature:** v0.3.3 Ray Marching Opacity Consistency
**Phase:** 01 of 03
**Focus:** Implement Beer-Lambert opacity correction in shader and API

## Scope

Implement the core opacity correction mechanism:
- Add `reference_step_size` parameter to RenderConfig
- Modify fragment shader to apply exponential opacity correction
- Update VolumeRenderer to pass reference_step_size uniform to shader
- Verify basic rendering functionality with correction enabled

This phase establishes the fundamental physics-based correction that makes all quality presets produce consistent visual results.

## Implementation

### Task 1: Add reference_step_size to RenderConfig

**File:** `pyvr/config.py`

**Changes:**

1. Add `reference_step_size` field to RenderConfig dataclass (after `opacity_threshold`):

```python
@dataclass
class RenderConfig:
    """Configuration for volume rendering quality and performance."""

    step_size: float
    max_steps: int
    early_ray_termination: bool = True
    opacity_threshold: float = 0.95
    reference_step_size: float = 0.01  # NEW
```

2. Add comprehensive docstring for the new parameter:

```python
reference_step_size: float = 0.01
    """Reference step size for opacity correction.

    Transfer functions define opacity at this reference step size.
    When rendering at different step sizes, opacity is corrected
    using Beer-Lambert law to maintain physical consistency.

    Guidelines:
    - Feature-dense volumes (medical, turbulence): 0.005-0.008
    - Simple volumes (synthetic, smooth fields): 0.015-0.02
    - Default (0.01): Matches balanced preset, good for most cases

    The same transfer function will produce identical appearance
    across all quality presets when reference_step_size is set correctly.

    Physical basis:
        alpha_corrected = 1.0 - exp(-alpha_tf * step_size / reference_step_size)

    This implements Beer-Lambert law for light absorption through a medium.
    """
```

3. Verify all existing preset methods work with the new field (they should automatically use default value):
   - `preview()`
   - `fast()`
   - `balanced()`
   - `high_quality()`
   - `ultra_quality()`

4. Verify `with_step_size()` and `with_max_steps()` methods still work correctly

**Verification:**
```python
# Test in Python REPL
from pyvr.config import RenderConfig

# All presets should work with default reference_step_size=0.01
config = RenderConfig.balanced()
assert config.reference_step_size == 0.01

# Manual construction should work
config = RenderConfig(step_size=0.005, max_steps=1000, reference_step_size=0.008)
assert config.reference_step_size == 0.008

# Modification methods should preserve reference_step_size
config = RenderConfig.fast().with_step_size(0.015)
assert config.reference_step_size == 0.01  # Default preserved
```

### Task 2: Modify Fragment Shader for Opacity Correction

**File:** `pyvr/shaders/volume.frag.glsl`

**Changes:**

1. Add new uniform after line 10 (after `uniform int max_steps;`):

```glsl
uniform float reference_step_size;
```

2. Modify opacity correction section (around lines 94-108):

**Before:**
```glsl
if (is_valid_texture_coord(tex_coord)) {
    float density = texture(volume_texture, tex_coord).r;

    // Single RGBA texture lookup for transfer function
    vec4 rgba = texture(transfer_function_lut, vec2(density, 0.5));
    vec3 rgb = rgba.rgb;
    float alpha = rgba.a;

    vec3 normal = texture(normal_volume, tex_coord).rgb;
    normal = normalize(normal);

    // Compute light direction from position to target (target is (0,0,0))
    vec3 light_dir = normalize(light_target - light_position);

    float diffuse_intensity = max(dot(normal, light_dir), 0.0);
    float light = ambient_light + diffuse_light * diffuse_intensity;

    vec4 sample_color = vec4(rgb * light, alpha);
    sample_color.rgb *= sample_color.a;
    accumulated_color += (1.0 - accumulated_alpha) * sample_color;
    accumulated_alpha += (1.0 - accumulated_alpha) * sample_color.a;
}
```

**After:**
```glsl
if (is_valid_texture_coord(tex_coord)) {
    float density = texture(volume_texture, tex_coord).r;

    // Single RGBA texture lookup for transfer function
    vec4 rgba = texture(transfer_function_lut, vec2(density, 0.5));
    vec3 rgb = rgba.rgb;
    float alpha_tf = rgba.a;

    // Apply step-size correction (Beer-Lambert law)
    float alpha_step_size_corrected = 1.0 - exp(-alpha_tf * step_size / reference_step_size);

    vec3 normal = texture(normal_volume, tex_coord).rgb;
    normal = normalize(normal);

    // Compute light direction from position to target (target is (0,0,0))
    vec3 light_dir = normalize(light_target - light_position);

    float diffuse_intensity = max(dot(normal, light_dir), 0.0);
    float light = ambient_light + diffuse_light * diffuse_intensity;

    vec4 sample_color = vec4(rgb * light, alpha_step_size_corrected);
    sample_color.rgb *= sample_color.a;
    accumulated_color += (1.0 - accumulated_alpha) * sample_color;
    accumulated_alpha += (1.0 - accumulated_alpha) * sample_color.a;
}
```

**Key changes:**
- Rename `alpha` â†’ `alpha_tf` (transfer function alpha, raw value)
- Add opacity correction: `alpha_step_size_corrected = 1.0 - exp(-alpha_tf * step_size / reference_step_size)`
- Use `alpha_step_size_corrected` in `sample_color` construction
- No changes to accumulation logic (lines with `accumulated_color` and `accumulated_alpha`)

**Verification:**
- Shader should compile without errors
- Shader uses new uniform `reference_step_size`
- Correction applied immediately after transfer function lookup
- Corrected alpha used consistently throughout rest of shader

### Task 3: Update VolumeRenderer to Pass Uniform

**File:** `pyvr/moderngl_renderer/renderer.py`

**Changes:**

1. Find where shader uniforms are initialized in `__init__` (search for `self.program['step_size']`):

Add after existing step_size and max_steps initialization:
```python
# Set rendering parameters
self.program['step_size'].value = self._config.step_size
self.program['max_steps'].value = self._config.max_steps
self.program['reference_step_size'].value = self._config.reference_step_size  # NEW
```

2. Update `set_config()` method (search for `def set_config`):

Add after existing step_size and max_steps updates:
```python
def set_config(self, config: RenderConfig) -> None:
    """Update render configuration."""
    self._config = config
    if self.program is not None:
        self.program['step_size'].value = config.step_size
        self.program['max_steps'].value = config.max_steps
        self.program['reference_step_size'].value = config.reference_step_size  # NEW
```

**Verification:**
```python
# Test in Python
from pyvr.moderngl_renderer import VolumeRenderer
from pyvr.config import RenderConfig
from pyvr.volume import Volume
from pyvr.datasets import create_sample_volume

# Create volume
volume_data = create_sample_volume(64, 'sphere')
volume = Volume(data=volume_data)

# Test with default config
renderer = VolumeRenderer(width=256, height=256)
renderer.load_volume(volume)
assert renderer.get_config().reference_step_size == 0.01

# Test with custom reference_step_size
config = RenderConfig(step_size=0.005, max_steps=500, reference_step_size=0.008)
renderer.set_config(config)
assert renderer.get_config().reference_step_size == 0.008

# Verify rendering still works (should not crash)
data = renderer.render()
assert data is not None
```

### Task 4: Verify No ModernGLManager Changes Needed

**File:** `pyvr/moderngl_renderer/manager.py`

**Action:** Read through ModernGLManager to confirm shader compilation automatically handles new uniform.

**Expected:** No changes needed - ModernGL automatically detects and exposes shader uniforms.

**Verification:**
- Shader compiles successfully with new uniform
- No errors about missing uniform binding
- `self.program['reference_step_size']` is accessible in renderer

## Verification Steps

### Step 1: Verify RenderConfig Parameter

```bash
python -c "
from pyvr.config import RenderConfig

# Test default value
config = RenderConfig.balanced()
assert config.reference_step_size == 0.01, 'Default should be 0.01'

# Test all presets
for preset_name in ['preview', 'fast', 'balanced', 'high_quality', 'ultra_quality']:
    preset_method = getattr(RenderConfig, preset_name)
    config = preset_method()
    assert config.reference_step_size == 0.01, f'{preset_name} should have default 0.01'
    print(f'{preset_name}: reference_step_size = {config.reference_step_size}')

# Test custom value
config = RenderConfig(step_size=0.01, max_steps=500, reference_step_size=0.005)
assert config.reference_step_size == 0.005, 'Custom value should be preserved'

print('âœ“ RenderConfig parameter tests passed')
"
```

### Step 2: Verify Shader Compiles

```bash
python -c "
from pyvr.moderngl_renderer import VolumeRenderer
from pyvr.volume import Volume
from pyvr.datasets import create_sample_volume
import numpy as np

# Create minimal test volume
volume_data = create_sample_volume(32, 'sphere')
volume = Volume(data=volume_data)

# Create renderer (will compile shader)
renderer = VolumeRenderer(width=128, height=128)
renderer.load_volume(volume)

# Verify uniform exists
assert 'reference_step_size' in renderer.program, 'Uniform should exist in shader'

print('âœ“ Shader compiles successfully with new uniform')
"
```

### Step 3: Verify Rendering Works

```bash
python -c "
from pyvr.moderngl_renderer import VolumeRenderer
from pyvr.config import RenderConfig
from pyvr.volume import Volume
from pyvr.datasets import create_sample_volume
from pyvr.transferfunctions import ColorTransferFunction, OpacityTransferFunction
import numpy as np

# Create test volume
volume_data = create_sample_volume(64, 'sphere')
volume = Volume(data=volume_data)

# Test with default config
renderer = VolumeRenderer(width=256, height=256)
renderer.load_volume(volume)

# Set transfer functions
ctf = ColorTransferFunction.from_colormap('viridis')
otf = OpacityTransferFunction.linear(0.0, 0.5)
renderer.set_transfer_functions(ctf, otf)

# Render at different presets
for preset_name in ['preview', 'balanced', 'high_quality']:
    preset_method = getattr(RenderConfig, preset_name)
    config = preset_method()
    renderer.set_config(config)

    data = renderer.render()
    assert data is not None, f'{preset_name} should render'

    # Verify data is valid
    image = np.frombuffer(data, dtype=np.uint8).reshape((256, 256, 4))
    assert image.shape == (256, 256, 4), 'Image shape should be correct'
    assert image.max() > 0, f'{preset_name} should produce non-black image'

    print(f'âœ“ {preset_name}: rendered successfully')

print('âœ“ All rendering tests passed')
"
```

### Step 4: Verify Opacity Correction is Applied

```bash
python -c "
from pyvr.moderngl_renderer import VolumeRenderer
from pyvr.config import RenderConfig
from pyvr.volume import Volume
from pyvr.datasets import create_sample_volume
from pyvr.transferfunctions import ColorTransferFunction, OpacityTransferFunction
import numpy as np

# Create test volume
volume_data = create_sample_volume(64, 'sphere')
volume = Volume(data=volume_data)

renderer = VolumeRenderer(width=256, height=256)
renderer.load_volume(volume)

# Use same transfer function for all presets
ctf = ColorTransferFunction.from_colormap('viridis')
otf = OpacityTransferFunction.linear(0.0, 0.5)
renderer.set_transfer_functions(ctf, otf)

# Render at preview and high_quality
# They should now look MORE SIMILAR than before (though not identical due to sampling)
renderer.set_config(RenderConfig.preview())
data_preview = renderer.render()
img_preview = np.frombuffer(data_preview, dtype=np.uint8).reshape((256, 256, 4))

renderer.set_config(RenderConfig.high_quality())
data_hq = renderer.render()
img_hq = np.frombuffer(data_hq, dtype=np.uint8).reshape((256, 256, 4))

# Both should have non-zero alpha (not fully transparent)
assert img_preview[:,:,3].max() > 0, 'Preview should have opacity'
assert img_hq[:,:,3].max() > 0, 'High quality should have opacity'

print(f'Preview mean alpha: {img_preview[:,:,3].mean():.1f}')
print(f'High quality mean alpha: {img_hq[:,:,3].mean():.1f}')
print('âœ“ Opacity correction is being applied (verify visually that presets look similar)')
"
```

## Validation

### Integration Test: Multi-Preset Rendering

Create a test script to render the same volume at all 5 presets and verify:
1. All renders complete without errors
2. All renders produce non-black images
3. Opacity values are in reasonable range
4. No shader compilation errors

```python
# Save as: test_phase01_integration.py
from pyvr.moderngl_renderer import VolumeRenderer
from pyvr.config import RenderConfig
from pyvr.volume import Volume
from pyvr.datasets import create_sample_volume
from pyvr.transferfunctions import ColorTransferFunction, OpacityTransferFunction
import numpy as np

def test_all_presets():
    """Test rendering at all quality presets with opacity correction."""
    # Create test volume
    volume_data = create_sample_volume(128, 'double_sphere')
    volume = Volume(data=volume_data)

    renderer = VolumeRenderer(width=512, height=512)
    renderer.load_volume(volume)

    # Set transfer functions
    ctf = ColorTransferFunction.from_colormap('plasma')
    otf = OpacityTransferFunction.linear(0.0, 0.3)
    renderer.set_transfer_functions(ctf, otf)

    presets = ['preview', 'fast', 'balanced', 'high_quality', 'ultra_quality']

    for preset_name in presets:
        print(f"\nTesting {preset_name}...")

        # Get preset config
        preset_method = getattr(RenderConfig, preset_name)
        config = preset_method()
        renderer.set_config(config)

        # Render
        data = renderer.render()
        image = np.frombuffer(data, dtype=np.uint8).reshape((512, 512, 4))

        # Verify
        assert image.shape == (512, 512, 4), f"{preset_name}: Wrong shape"
        assert image[:,:,3].max() > 0, f"{preset_name}: Fully transparent"
        assert image[:,:,:3].max() > 0, f"{preset_name}: Black image"

        # Print stats
        mean_alpha = image[:,:,3].mean()
        max_alpha = image[:,:,3].max()
        print(f"  reference_step_size: {config.reference_step_size}")
        print(f"  step_size: {config.step_size}")
        print(f"  Mean alpha: {mean_alpha:.1f}")
        print(f"  Max alpha: {max_alpha}")
        print(f"  âœ“ {preset_name} rendered successfully")

    print("\nâœ“ All presets rendered successfully with opacity correction")

if __name__ == '__main__':
    test_all_presets()
```

Run:
```bash
python test_phase01_integration.py
```

Expected output: All presets render successfully, alpha values should be relatively consistent across presets (within reasonable range given sampling differences).

### Visual Validation

Optional manual check:
```python
# Save rendered images for visual comparison
from pyvr.moderngl_renderer import VolumeRenderer
from pyvr.config import RenderConfig
from pyvr.volume import Volume
from pyvr.datasets import create_sample_volume
from pyvr.transferfunctions import ColorTransferFunction, OpacityTransferFunction
from PIL import Image
import numpy as np

volume_data = create_sample_volume(128, 'sphere')
volume = Volume(data=volume_data)

renderer = VolumeRenderer(width=512, height=512)
renderer.load_volume(volume)

ctf = ColorTransferFunction.from_colormap('viridis')
otf = OpacityTransferFunction.linear(0.0, 0.4)
renderer.set_transfer_functions(ctf, otf)

for preset_name in ['preview', 'fast', 'balanced', 'high_quality', 'ultra_quality']:
    preset_method = getattr(RenderConfig, preset_name)
    renderer.set_config(preset_method())

    image = renderer.render_to_pil()
    image.save(f'phase01_test_{preset_name}.png')
    print(f'Saved: phase01_test_{preset_name}.png')

print("\nVisually compare images - they should look similar in overall opacity")
```

## Acceptance Criteria

- [ ] `reference_step_size` parameter added to RenderConfig with default 0.01
- [ ] Comprehensive docstring added explaining usage and physics
- [ ] All existing preset methods work with new parameter
- [ ] Fragment shader modified to apply Beer-Lambert opacity correction
- [ ] New uniform `reference_step_size` declared in shader
- [ ] Opacity correction formula correctly implemented: `1.0 - exp(-alpha_tf * step_size / reference_step_size)`
- [ ] VolumeRenderer passes reference_step_size uniform in constructor
- [ ] VolumeRenderer passes reference_step_size uniform in set_config()
- [ ] Shader compiles without errors
- [ ] Rendering works at all 5 quality presets
- [ ] No regression: existing rendering functionality still works
- [ ] Integration test passes for all presets
- [ ] Code follows existing style and conventions

## Git Commit

**When all acceptance criteria are met**, commit with:

```bash
git add pyvr/config.py pyvr/shaders/volume.frag.glsl pyvr/moderngl_renderer/renderer.py
git commit -m "$(cat <<'EOF'
feat(rendering): Implement Beer-Lambert opacity correction

Add step-size corrected opacity for physically consistent rendering
across all quality presets. Fixes critical bug where high quality
presets appeared too opaque and low quality too transparent.

Changes:
- Add reference_step_size parameter to RenderConfig (default: 0.01)
- Modify fragment shader to apply exponential opacity correction
- Update VolumeRenderer to pass reference_step_size uniform
- Opacity formula: 1.0 - exp(-alpha_tf * step_size / reference_step_size)

This implements Beer-Lambert law for light absorption, ensuring
all quality presets produce visually consistent results differing
only in sampling smoothness, not overall opacity.

Breaking change: Visual appearance will change at non-balanced presets.
High quality will render lighter, low quality darker. This is the
physically correct behavior.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"
```

## Notes for Next Phase

Phase 02 will add comprehensive testing:
- Unit tests for opacity correction formula
- Tests for RenderConfig parameter behavior
- Visual comparison validation across presets
- Regression tests to ensure no breakage

The implementation in Phase 01 should be functionally complete and rendering correctly before proceeding to Phase 02.
