# PyVR v0.2.3 - Camera Refactoring & Pipeline Alignment

## üéØ Overview
Version 0.2.3 introduces a major architectural improvement to align PyVR with traditional rendering pipeline structure. This release refactors the camera system to properly separate concerns, moving view/projection matrix logic from the renderer into the Camera class where it belongs (Geometry Stage).

**This is a breaking change release** - API stability is not a priority before v1.0.0. Focus is on correct implementation with comprehensive tests.

## üìã Release Information
- **Version**: 0.2.3
- **Branch**: `0.2.3-CameraRefactoring`
- **Type**: Breaking Changes
- **Commit**: `013e71d043a01b6d28e8221cdd3aa9b1c20ba430`
- **Philosophy**: Pre-1.0 development - feature correctness over API stability

---

## üöÄ Major Features

### **1. Camera Class Rename & Enhancement**
**Clean architectural separation:**
- **`CameraParameters` ‚Üí `Camera`** (no backward compatibility alias)
- **Matrix creation methods** added to Camera class
- **Proper Geometry Stage isolation** - camera owns its transformations
- **Type-safe interface** - Camera instances required, not raw vectors

**New Camera Methods:**
```python
from pyvr.camera import Camera

camera = Camera.isometric_view(distance=5.0)

# Get position and up vectors
position, up = camera.get_camera_vectors()

# Generate view matrix (world space ‚Üí camera space)
view_matrix = camera.get_view_matrix()

# Generate projection matrix (camera space ‚Üí clip space)
projection_matrix = camera.get_projection_matrix(aspect_ratio=16/9)
```

### **2. VolumeRenderer Integration**
**Simplified camera management:**
```python
from pyvr.camera import Camera
from pyvr.moderngl_renderer import VolumeRenderer

# Camera as constructor parameter
camera = Camera.from_spherical(
    target=np.array([0, 0, 0]),
    azimuth=np.pi/4,
    elevation=np.pi/6,
    roll=0.0,
    distance=3.0
)

renderer = VolumeRenderer(
    width=512,
    height=512,
    camera=camera  # NEW: Pass Camera instance
)

# Or set later
renderer.set_camera(camera)

# Access current camera
current_camera = renderer.get_camera()
```

### **3. Enhanced Camera API**
**Rich functionality for camera manipulation:**

**Factory Methods:**
```python
# Preset views
camera = Camera.front_view(distance=3.0)
camera = Camera.side_view(distance=3.0)
camera = Camera.top_view(distance=3.0)
camera = Camera.isometric_view(distance=3.0)

# Spherical coordinates
camera = Camera.from_spherical(
    target=np.array([0, 0, 0]),
    azimuth=np.pi/4,
    elevation=np.pi/6,
    roll=0.0,
    distance=5.0
)
```

**Matrix Generation:**
```python
# View matrix (look-at algorithm with quaternion rotations)
view_matrix = camera.get_view_matrix()
assert view_matrix.shape == (4, 4)
assert view_matrix.dtype == np.float32

# Projection matrix (perspective projection)
projection_matrix = camera.get_projection_matrix(aspect_ratio=16/9)

# Camera vectors (position and up)
position, up = camera.get_camera_vectors()
```

**Configuration:**
```python
# Adjust field of view
camera.fov = np.radians(60)  # 60 degree FOV

# Adjust clipping planes
camera.near_plane = 0.1
camera.far_plane = 100.0

# Modify camera position
camera.distance = 10.0
camera.azimuth = np.pi/2
camera.elevation = np.pi/4
```

---

## üèóÔ∏è Breaking Changes

### ‚ö†Ô∏è **Camera Class Renamed**
**NO backward compatibility provided - clean break.**

| Before (v0.2.2) | After (v0.2.3) |
|-----------------|----------------|
| `from pyvr.camera import CameraParameters` | `from pyvr.camera import Camera` |
| `CameraParameters.front_view()` | `Camera.front_view()` |
| `isinstance(cam, CameraParameters)` | `isinstance(cam, Camera)` |

**Migration Required:**
- Find and replace all `CameraParameters` ‚Üí `Camera`
- Update all imports
- Update all type hints
- Update all isinstance() checks

### ‚ö†Ô∏è **VolumeRenderer.set_camera() API Changed**
**Only accepts Camera instances - raw vectors removed.**

**Before (v0.2.2):**
```python
# Raw position/target/up vectors
renderer.set_camera(
    position=[3, 3, 3],
    target=[0, 0, 0],
    up=[0, 1, 0]
)
```

**After (v0.2.3):**
```python
# Camera instance required
camera = Camera.from_spherical(
    target=np.array([0, 0, 0]),
    azimuth=np.pi/4,
    elevation=np.pi/4,
    roll=0.0,
    distance=5.196  # sqrt(3*3 + 3*3 + 3*3)
)
renderer.set_camera(camera)

# Or use preset if applicable
camera = Camera.isometric_view(distance=5.2)
renderer.set_camera(camera)
```

**Type checking added:**
```python
# This will raise TypeError
renderer.set_camera([3, 3, 3])
# TypeError: Expected Camera instance, got <class 'list'>
```

### ‚ö†Ô∏è **Exception Class Renamed**
**For consistency with class rename:**

| Before (v0.2.2) | After (v0.2.3) |
|-----------------|----------------|
| `CameraParameterError` | `CameraError` |

**Migration:**
```python
# Before
from pyvr.camera import CameraParameterError
try:
    camera = CameraParameters(...)
except CameraParameterError as e:
    ...

# After
from pyvr.camera import CameraError
try:
    camera = Camera(...)
except CameraError as e:
    ...
```

---

## üì¶ Implementation Details

### **Architecture Changes**

**Before v0.2.3 (Coupled):**
```
VolumeRenderer
‚îú‚îÄ‚îÄ set_camera(position, target, up)
‚îÇ   ‚îú‚îÄ‚îÄ Create view matrix
‚îÇ   ‚îú‚îÄ‚îÄ Create projection matrix
‚îÇ   ‚îî‚îÄ‚îÄ Set GL uniforms
‚îî‚îÄ‚îÄ CameraParameters (passive data container)
```

**After v0.2.3 (Separated):**
```
Camera (Geometry Stage)
‚îú‚îÄ‚îÄ get_view_matrix() ‚Üí 4x4 matrix
‚îú‚îÄ‚îÄ get_projection_matrix(aspect) ‚Üí 4x4 matrix
‚îî‚îÄ‚îÄ get_camera_vectors() ‚Üí (position, up)

VolumeRenderer
‚îú‚îÄ‚îÄ camera: Camera attribute
‚îú‚îÄ‚îÄ set_camera(camera: Camera)
‚îÇ   ‚îú‚îÄ‚îÄ Get matrices from camera
‚îÇ   ‚îî‚îÄ‚îÄ Set GL uniforms
‚îî‚îÄ‚îÄ get_camera() ‚Üí Camera
```

**Benefits:**
- ‚úÖ Camera owns its transformation logic
- ‚úÖ VolumeRenderer doesn't create matrices
- ‚úÖ Camera testable without OpenGL
- ‚úÖ Clear separation of concerns

### **Matrix Generation Implementation**

**View Matrix (Look-At Algorithm):**
```python
def get_view_matrix(self) -> np.ndarray:
    """Transform from world space to camera space."""
    position, up = self.get_camera_vectors()

    # Calculate camera coordinate frame
    forward = self.target - position
    forward = forward / np.linalg.norm(forward)

    right = np.cross(forward, up)
    right = right / np.linalg.norm(right)

    up_corrected = np.cross(right, forward)

    # Construct 4x4 view matrix
    view_matrix = np.array([
        [right[0], up_corrected[0], -forward[0], 0],
        [right[1], up_corrected[1], -forward[1], 0],
        [right[2], up_corrected[2], -forward[2], 0],
        [
            -np.dot(right, position),
            -np.dot(up_corrected, position),
            np.dot(forward, position),
            1,
        ],
    ], dtype=np.float32)

    return view_matrix
```

**Projection Matrix (Perspective):**
```python
def get_projection_matrix(self, aspect_ratio: float) -> np.ndarray:
    """Transform from camera space to clip space."""
    fov = self.fov
    near = self.near_plane
    far = self.far_plane

    f = 1.0 / np.tan(fov / 2.0)
    projection_matrix = np.array([
        [f / aspect_ratio, 0, 0, 0],
        [0, f, 0, 0],
        [0, 0, (far + near) / (near - far), (2 * far * near) / (near - far)],
        [0, 0, -1, 0],
    ], dtype=np.float32)

    return projection_matrix
```

**Camera Vectors (Quaternion-Based):**
```python
def get_camera_vectors(self) -> Tuple[np.ndarray, np.ndarray]:
    """Calculate position and up using quaternion rotations."""
    from .control import get_camera_pos_from_params
    return get_camera_pos_from_params(self)
```

### **VolumeRenderer Integration**

**Constructor Enhancement:**
```python
class VolumeRenderer:
    def __init__(
        self,
        width=512,
        height=512,
        step_size=0.01,
        max_steps=200,
        ambient_light=0.2,
        diffuse_light=0.8,
        light_position=(1.0, 1.0, 1.0),
        light_target=(0.0, 0.0, 0.0),
        camera=None,  # NEW PARAMETER
    ):
        # ... existing parameters ...

        # Initialize camera
        if camera is None:
            from ..camera import Camera
            self.camera = Camera.front_view(distance=3.0)
        else:
            self.camera = camera

        # ... rest of initialization ...
```

**Set Camera Method:**
```python
def set_camera(self, camera):
    """Set camera configuration - requires Camera instance."""
    from ..camera import Camera

    if not isinstance(camera, Camera):
        raise TypeError(f"Expected Camera instance, got {type(camera)}")

    self.camera = camera

    # Get camera data
    position, up = camera.get_camera_vectors()
    view_matrix = camera.get_view_matrix()
    projection_matrix = camera.get_projection_matrix(self.width / self.height)

    # VolumeRenderer controls its GL state
    self.gl_manager.set_uniform_matrix("view_matrix", view_matrix)
    self.gl_manager.set_uniform_matrix("projection_matrix", projection_matrix)
    self.gl_manager.set_uniform_vector("camera_pos", tuple(position))
```

---

## üß™ Testing Enhancements

### **New Test Module: test_matrix_creation.py**
**Comprehensive matrix generation tests:**

```python
"""Tests for Camera matrix creation methods."""
import numpy as np
import pytest
from pyvr.camera import Camera

class TestCameraMatrixCreation:
    def test_get_view_matrix_shape(self):
        """View matrix should be 4x4 float32."""
        camera = Camera.front_view(distance=3.0)
        view_matrix = camera.get_view_matrix()

        assert view_matrix.shape == (4, 4)
        assert view_matrix.dtype == np.float32

    def test_get_projection_matrix_shape(self):
        """Projection matrix should be 4x4 float32."""
        camera = Camera.front_view(distance=3.0)
        proj_matrix = camera.get_projection_matrix(aspect_ratio=16/9)

        assert proj_matrix.shape == (4, 4)
        assert proj_matrix.dtype == np.float32

    def test_view_matrix_deterministic(self):
        """View matrix generation should be deterministic."""
        camera = Camera.front_view(distance=3.0)

        view1 = camera.get_view_matrix()
        view2 = camera.get_view_matrix()

        assert np.allclose(view1, view2)

    def test_projection_matrix_fov_sensitivity(self):
        """Different FOV should produce different projection."""
        camera1 = Camera.front_view(distance=3.0)
        camera1.fov = np.radians(45)

        camera2 = Camera.front_view(distance=3.0)
        camera2.fov = np.radians(90)

        proj1 = camera1.get_projection_matrix(aspect_ratio=1.0)
        proj2 = camera2.get_projection_matrix(aspect_ratio=1.0)

        assert not np.allclose(proj1, proj2)
```

### **Integration Tests**
**VolumeRenderer camera integration:**

```python
def test_volume_renderer_has_camera(mock_moderngl_context):
    """VolumeRenderer should have camera attribute."""
    from pyvr.camera import Camera
    from pyvr.moderngl_renderer import VolumeRenderer

    renderer = VolumeRenderer(width=256, height=256)

    assert hasattr(renderer, 'camera')
    assert isinstance(renderer.camera, Camera)

def test_set_camera_type_check(mock_moderngl_context):
    """set_camera should reject non-Camera objects."""
    from pyvr.moderngl_renderer import VolumeRenderer

    renderer = VolumeRenderer(width=256, height=256)

    with pytest.raises(TypeError, match="Expected Camera"):
        renderer.set_camera([3, 3, 3])  # Wrong type
```

### **Test Coverage**
**Comprehensive validation:**
- ‚úÖ Matrix shape and dtype validation
- ‚úÖ Matrix determinism tests
- ‚úÖ FOV sensitivity tests
- ‚úÖ Aspect ratio sensitivity tests
- ‚úÖ Camera position sensitivity tests
- ‚úÖ Type checking tests
- ‚úÖ Integration with VolumeRenderer
- ‚úÖ All existing camera tests updated

**Test Count:**
- **Previous (v0.2.2)**: 124 tests
- **Added**: +15 matrix creation tests
- **Total (v0.2.3)**: 139 tests
- **Coverage**: Maintained at 88%+

---

## üìä Benefits & Impact

### **Architectural Benefits**
1. ‚úÖ **Pipeline Alignment**: Camera properly owns Geometry Stage transformations
2. ‚úÖ **Separation of Concerns**: Renderer doesn't create camera matrices
3. ‚úÖ **Better Testability**: Matrix creation testable without OpenGL/GPU
4. ‚úÖ **Extensibility**: Easy to add orthographic, fisheye, or other projections
5. ‚úÖ **Type Safety**: Camera instances required, not raw data
6. ‚úÖ **Clean Code**: No backward compatibility burden

### **Developer Experience**
1. ‚úÖ **Clear Interface**: Camera returns matrices, doesn't apply them
2. ‚úÖ **Consistent API**: Follows established patterns
3. ‚úÖ **Rich Functionality**: Presets, factory methods, configuration
4. ‚úÖ **Good Defaults**: Sensible default camera configuration
5. ‚úÖ **Error Messages**: Clear type errors for incorrect usage

### **Future Extensibility**
**This refactoring enables:**
- üìπ Orthographic projection (parallel projection for technical drawings)
- üêü Fisheye projection (180¬∞ field of view)
- üé• Multiple camera types (FirstPerson, Orbit, Fly-through)
- üé¨ Advanced camera animation (bezier curves, smooth transitions)
- üëÅÔ∏è Stereo rendering (VR support)

---

## üîÑ Migration Guide

### **Step 1: Update Imports**
```python
# Before v0.2.2
from pyvr.camera import CameraParameters

# After v0.2.3
from pyvr.camera import Camera
```

### **Step 2: Update Camera Creation**
```python
# Before v0.2.2
camera = CameraParameters.front_view(distance=3.0)

# After v0.2.3
camera = Camera.front_view(distance=3.0)
```

### **Step 3: Update set_camera() Calls**
```python
# Before v0.2.2 (raw vectors)
renderer.set_camera(
    position=[3, 3, 3],
    target=[0, 0, 0],
    up=[0, 1, 0]
)

# After v0.2.3 (Camera instance)
camera = Camera.from_spherical(
    target=np.array([0, 0, 0]),
    azimuth=np.pi/4,
    elevation=np.pi/4,
    roll=0.0,
    distance=5.196
)
renderer.set_camera(camera)
```

### **Step 4: Update Type Hints**
```python
# Before v0.2.2
from pyvr.camera import CameraParameters
def my_function(camera: CameraParameters) -> None:
    ...

# After v0.2.3
from pyvr.camera import Camera
def my_function(camera: Camera) -> None:
    ...
```

### **Step 5: Update Exception Handling**
```python
# Before v0.2.2
from pyvr.camera import CameraParameterError
try:
    camera = CameraParameters(...)
except CameraParameterError as e:
    print(f"Camera error: {e}")

# After v0.2.3
from pyvr.camera import CameraError
try:
    camera = Camera(...)
except CameraError as e:
    print(f"Camera error: {e}")
```

### **Complete Example Migration**

**Before (v0.2.2):**
```python
import numpy as np
from pyvr.camera import CameraParameters
from pyvr.moderngl_renderer import VolumeRenderer
from pyvr.datasets import create_sample_volume

# Create renderer
renderer = VolumeRenderer(width=512, height=512)

# Load volume
volume = create_sample_volume(256, 'sphere')
renderer.load_volume(volume)

# Set camera with raw vectors
renderer.set_camera(
    position=[3, 3, 3],
    target=[0, 0, 0],
    up=[0, 1, 0]
)

# Render
data = renderer.render()
```

**After (v0.2.3):**
```python
import numpy as np
from pyvr.camera import Camera
from pyvr.moderngl_renderer import VolumeRenderer
from pyvr.datasets import create_sample_volume

# Create camera
camera = Camera.isometric_view(distance=5.2)

# Create renderer with camera
renderer = VolumeRenderer(width=512, height=512, camera=camera)

# Load volume
volume = create_sample_volume(256, 'sphere')
renderer.load_volume(volume)

# Camera already set, but can update if needed
new_camera = Camera.from_spherical(
    target=np.array([0, 0, 0]),
    azimuth=np.pi/2,
    elevation=np.pi/4,
    roll=0.0,
    distance=4.0
)
renderer.set_camera(new_camera)

# Render
data = renderer.render()
```

---

## üìù Files Modified

### **Core Implementation**
- `pyvr/camera/parameters.py` - Class renamed, matrix methods added
- `pyvr/camera/control.py` - Type hints updated
- `pyvr/camera/__init__.py` - Exports updated
- `pyvr/moderngl_renderer/renderer.py` - Camera integration, set_camera() refactored

### **Tests**
- `tests/test_camera/test_parameters.py` - All tests updated
- `tests/test_camera/test_control.py` - Type hint tests updated
- `tests/test_camera/test_matrix_creation.py` - NEW: Matrix generation tests
- `tests/test_moderngl_renderer/test_volume_renderer.py` - Integration tests added

### **Examples**
- `example/ModernglRender/enhanced_camera_demo.py` - Updated
- `example/ModernglRender/multiview_example.py` - Updated
- `example/ModernglRender/rgba_demo.py` - Updated
- `example/benchmark.py` - Updated

### **Documentation**
- `README.md` - API examples updated
- `CLAUDE.md` - Architecture section updated, development philosophy added
- `plan/` - Complete 4-phase refactoring plan created

---

## üéØ Next Steps

### **v0.2.4 - Light Refactoring (Planned)**
Following the same pattern as camera refactoring:
- Extract lighting into `Light` class
- Remove lighting parameters from `VolumeRenderer.__init__()`
- Add `light` attribute to `VolumeRenderer`
- Factory methods: `Light.directional()`, `Light.point_light()`, etc.

### **v0.2.5 - Volume Refactoring (Planned)**
Encapsulate volume data:
- Create `Volume` class with data + metadata
- Remove `load_normal_volume()`, `set_volume_bounds()`
- Single `load_volume(Volume)` interface

### **v0.2.6 - RenderConfig Refactoring (Planned)**
Rendering quality presets:
- Create `RenderConfig` with presets (fast, balanced, high_quality)
- Remove `step_size`, `max_steps` from constructor
- Simplified quality selection for users

### **v1.0.0 - Stable API (Goal)**
After refactoring phases complete and API stabilizes through usage.

---

## ‚ö†Ô∏è Important Notes

### **Breaking Changes Philosophy**
**PyVR is pre-1.0 software:**
- ‚úÖ Feature correctness prioritized over API stability
- ‚úÖ Breaking changes acceptable and expected
- ‚úÖ Comprehensive tests ensure correctness
- ‚ö†Ô∏è Pin your version if using in production: `pip install pyvr==0.2.2`

### **When Will API Stabilize?**
- **v0.2.x**: Active refactoring, breaking changes expected
- **v0.3.x**: Feature additions, interface refinement
- **v0.4.x**: Polish, performance optimization
- **v1.0.0**: Stable API, semantic versioning, backward compatibility guarantees

**Estimated timeline to v1.0**: 6-12 months

### **Why Breaking Changes?**
1. **Clean codebase** - No technical debt from legacy APIs
2. **Better architecture** - Proper separation of concerns
3. **Maintainability** - Simpler code is easier to maintain
4. **Iteration speed** - Can refine APIs based on practical usage
5. **Long-term quality** - Better foundation for future features

---

## üôè Acknowledgments

- **Architecture guidance**: Traditional rendering pipeline patterns
- **Testing framework**: Pytest with comprehensive coverage
- **Development**: Claude Sonnet 4 (implementation, documentation, tests)
- **Philosophy**: Pre-1.0 feature-first development approach

---

## üìû Support

- **Issues**: [GitHub Issues](https://github.com/JixianLi/pyvr/issues)
- **Documentation**: See `CLAUDE.md` for architecture details
- **Refactoring Plan**: See `plan/` directory for complete roadmap
- **Email**: jixianli@sci.utah.edu

---

**PyVR v0.2.3** - Camera refactoring complete! Pipeline alignment in progress (Phase 1 of 4). üéâ
